# JavaScript [2025-02-19]

## 새로 배운 내용
오늘은 JavaScript의 전반적인 이해를 위해 공부를 진행했다.

<br/>

JavaScript는 인터프리터 혹은 JIT(Just-In-Time) 컴파일 프로그래밍 언어로, 객체지향형, 명령형, 선언형(함수형 프로그래밍 등) 스타일을 지원한다.

- 프론트엔드: 함수형 프로그래밍(FP) 중심 (`React Hooks`, `Vue Composition API`).
- 백엔드: 객체 지향(OOP) + 함수형 조합 (`NestJS`, `Express`)

<br/>

### 1. 객체(Object)

JavaScript에서 객체는 `key`와 `value`로 구성된 `property`(속성)들의 집합을 뜻한다.

- 값(`value`)으로 **모든 데이터 타입**이 올 수 있다.
- 객체의 속성 값으로 함수를 정의하면 **메서드(`method`)**가 된다.

<br/>

> 객체를 통해, 우리는 필요한 데이터와 그와 관련된 연산을 **묶어서 관리할 수 있다.**

<br/>

#### 1-1. 사용방법

객체를 사용하는 방법은 “**저장**”과 “**접근 혹은 수정**”으로 나눌 수 있다.

1. **저장**: 키-값 쌍을 사용해 데이터를 저장
2. **접근 혹은 수정**: 점 표기법이나 대괄호 표기법으로 속성에 접근하거나 수정한다.

<br/>

JavaScript 객체는 3가지 방법을 통해서 정의하고 사용할 수 있다.

- **객체 리터럴**

  ```jsx
  // 객체 정의
  var person = {
      // 프로퍼티
      name: "John",
      // 메서드
      walk: function(km) {
          console.log(`걷는다: ${km}km`);
      }
  };
  ```

- **생성자 함수**

  ```jsx
  function Person(name, age) {
    this.name = name;
    this.age = age;
    this.greet = function() {
      console.log('Hello, my name is ' + this.name + '!');
    };
  }
  ```

- **클래스**

  ```jsx
  class Person {
    constructor(name, age) { // 생성자
      this.name = name;
      this.age = age;
    }
  
    greet() {
      console.log('Hello, my name is ' + this.name + '!');
    }
  }
  ```

  - ES6(2015년)에서 `class` 문법이 추가되면서 OOP 스타일의 코드를 더 쉽게 작성할 수 있게 되었다.

<br/><br/>

### 2. 네임스페이스(Namespace)

> 네임스페이스는 프로그래밍에서 변수, 함수, 클래스와 같은 **식별자들을 그룹화하는 방법**을 말한다.

소프트웨어가 커질수록, 같은 이름을 가진 변수나 함수, 클래스 등이 많아질 수 있다.

따라서, 이를 방지하고 **코드를 모듈화**하기 위해 네임스페이스를 사용한다.

<br/>

📍 JavaScript에서 가장 흔하게 사용하는 네임스페이스 패턴은 **객체(Object)를 이용하는 것**이다.

```jsx
const MyNamespace = {
  name: "JavaScript",
  version: "ES6",

  greet: function() {
    console.log(`Welcome to ${this.name} ${this.version}!`);
  }
};

MyNamespace.greet(); // Welcome to JavaScript ES6!
```

<br/>

현대 JavaScript에서는 네임스페이스보다 **ES6 모듈 시스템(ESM)**을 사용하는 것이 일반적이다.

- 네임스페이스를 직접 구현하는 것보다, `import/export`를 활용한 모듈화가 더 효율적이고 유지보수가 쉽다.

> **📌 정리하자면**, 과거에는 네임스페이스를 객체, IIFE(즉시 실행 함수)패턴을 사용했지만, 최근에는 **ES6 모듈 시스템(ESM)**을 적극 활용하는 것이 좋다.

<br/>

<br/>

### 3. 함수형 패러다임

프로그래밍 패러다임에는 절차 지향 프로그래밍, 객체 지향 프로그래밍, 함수형 프로그래밍이 있다.

- 프로그래밍 패러다임은 프로그램을 구축하는데 사용되는 기본적인 접근 방식으로, 코드를 체계적이고 효율적으로 작성할 수 있도록 한다.

<br/>

**📍 여기서 JavaScript는 함수형 프로그래밍(FP) 패러다임을 강력하게 지원한다.**

> 함수형 프로그래밍 패러다임은 **함수를 “일급 객체 취급”**을 하고, 상태와 가변 데이터를 피하며, **순수 함수를 중심으로 프로그램을 작성**하는 패러다임이다.

- **일급 함수(First-Class Function)**: 함수를 “값”처럼 다룰 수 있고 다양한 패턴을 구현할 수 있다.
- **순수 함수(Pure Function)**: 부작용을 최소화, 데이터 불변성 유지, 예측 가능한 안정적인 코드 작성

<br/>

#### 3-1. 함수(Function)

함수는 재사용하기 위해 묶어놓은 하나의 작업 단위의 코드모음이다.

<br/>

> **JavaScript에서 함수를 작성하는 방법은 크게 3가지가 있다.**

1. **함수 선언문(Functional Declaration)**

   ```jsx
   // 선언 함수이름(매개변수)
   function greet(name) {
       return `Hello, ${name}`;
   }
   ```

2. **함수 표현식(Functional Expression)**

   ```jsx
   // 함수이름 = 선언(매개변수)
   const greet = function(name) { 
   		return `Hello, ${name}`
   }
   ```

3. **화살표 함수(Arrow Function)**

   ```jsx
   // 함수이름 = 매개변수
   const greet = (name) => `Hello, ${name}`;
   ```

<br/>

> **함수는 `,`로 구분된 여러 인자를 받을 수 있다.**

- 이 인자들은 어떤 타입의 값(객체, 함수 등)이든 받을 수 있다.
  - 객체를 인자로 사용하면 객체의 속성을 사용하여 편하게 작업을 수행할 수 있다.

<br/>

#### 3-2. 일급함수(first-class function)

> **JavaScript에서는 함수가 일급 객체(First-Class Citizen)로 취급된다.**

“함수들이 다른 변수처럼 다루어질 때 **일급 함수**를 가진다”라고 한다.

<br/>

**🔻 장점**: 함수를 변수처럼 다루면 다음과 같은 다양한 장점이 있다.

| **제목**             | **역할**                                             | **이점**                                       |
| -------------------- | ---------------------------------------------------- | ---------------------------------------------- |
| 코드의 재사용성 향상 | 함수를 변수에 저장하거나 다른 함수로 전달            | 중복 코드를 줄이고, 프로젝트의 일관성을 유지함 |
| 고차 함수 사용       | **함수를 다른 함수의 인자로** 전달하거나 결과로 반환 | 데이터 처리와 이벤트 처리에서 유용함           |
| 유연한 함수 처리     | **함수를 데이터 구조에 저장**하고 필요할 때 사용     | 이벤트 리스너나 콜백 함수 관리에 유용함        |
| 추상화와 캡슐화 용이 | 세부 구현을 숨기고 필요한 인터페이스만 제공          | **복잡한 로직을 간단한 함수 호출로 처리** 가능 |

- 함수 형태로 관리하게 되면 다른 함수 내에서 다양한 로직을 수행할 수 있다.

<br/>

특히, 추상화와 캡슐화에 대해서 알아보면 다음과 같다.

| **개념** | **설명**                                          | **예제**                        |
| -------- | ------------------------------------------------- | ------------------------------- |
| 추상화   | 불필요한 세부 사항을 감추고, 공통적인 기능을 제공 | 콜백 함수, 고차 함수 사용       |
| 캡슐화   | 외부에서 직접 접근할 수 없도록 데이터를 보호      | 클로저, 커링을 활용한 정보 은닉 |

- 일급 함수의 특성을 활용하여 각각의 동작을 함수로 분리해서 전달하면 추상화를 지킬 수 있다.

<br/>

### 3-3. 익명함수(Anonymous Function)

익명함수는 함수를 정의할 때 **함수명을 생략**하고, 함수 자체만을 선언하여 사용하는 함수를 뜻한다.

- 익명함수는 이벤트 리스너나 콜백으로 자주 사용되어 함수가 한 번만 사용되거나, 직접 함수명을 정의할 필요가 없는 경우 코드의 중복을 피할 수 있다.

<br/>

### 3-4. 즉시 실행 함수(IIFE: Immediately Invoked Function Expression)

즉시 실행 함수는 정의되자마자 “**즉시 실행**”되는 함수를 말한다.

- 다른 함수와 다르게 **한 번만 실행되며, 다시 호출할 수 없음**
- **전역 변수 오염 방지 (Encapsulation)**
  - 즉시 실행 함수 내부에 선언된 모든 변수와 함수는 해당 함수 외부에서 접근할 수 없기 때문에 전역 스코프를 오염시키지 않는다.

<br/>

즉시 실행함수는 다른 함수들과 다른 사용방법을 가진다.

```javascript
(function(greeting, name) {
    console.log(greeting + ", " + name + "!");
})("Hello", void");
```

1. 익명함수를 `()`로 감싸서 함수 선언한다.
   - [Grouping Operator](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Grouping) `()` 안에 어휘 범위로 둘러싸인 익명함수: `(function( ){ }) `
2. 선언한 함수 옆에 `()`를 붙여 즉시 실행 함수를 생성한다.
   1. 즉시 실행 함수를 생성하는 괄호`()`: `(익명함수)();`
   2. 이를 통해 JavaScript 엔진은 함수를 즉시 해석해서 실행한다.

<br/>

<br/>

### 4. 모듈 시스템

모듈이란 “재사용 가능한 코드 조각"으로, 관련된 함수, 변수, 클래스 등을 함께 묶어서 구성된 하나의 ‘독립적인 파일’을 뜻한다.

<br/>

> 모듈은 필요한 **기능별로 코드를 분리**해 파일 단위로 작성한다.

**🔻 장점**

- **재사용성, 유지보수성**

  - 모듈화를 통해 프로그램을 작은 부분으로 나누어 **재사용성**과 **유지보수성**을 향상시킬 수 있다.

- **네임스페이스 충돌 방지**

  - 기존 JavaScript에서는 모든 코드가 “전역 공간(Global Scope)”에 존재했기 때문에, 같은 이름의 변수가 충돌하는 문제가 발생했다.

  → 모듈화를 통해 네임스페이스 충돌을 방지할 수 있다.

<br/>

자바스크립트에서 모듈 시스템을 구현하는 방법은 크게 CJS(CommonJS), ESM(ECMAScript Modules) 방식으로 나뉜다.

#### 4-1. CJS(CommonJS) = module.exports

- **정의**: `exports` 객체를 이용한다.
- **사용**: `require` 함수를 이용한다.

<br/>

`require()`는 **동기적으로 모듈을 로드**하므로, 서버 사이드에서 빠른 실행이 가능하다.

따라서, Node.js를 활용한 **SSR** 개발 시 사용한다.

<br/>

#### 4-2. ESM(ECMAScript Modules) = export

프론트엔드 영역에서 표준화되어 널리 쓰이는 방식으로, ES6 모듈은 브라우저 환경에서 최적화되어 있다.

<br/>

`import/export`는 **비동기적**으로 동작한다.

- **정의**: `export` 객체
- **사용**: `import` 객체

| 특징        | **CommonJS (CJS)**                                     | **ES6 모듈 (ESM)**                                   |
| ----------- | ------------------------------------------------------ | ---------------------------------------------------- |
| 사용 방식   | `require()` / `module.exports`                         | `import` / `export`                                  |
| 실행 방식   | 동기적(싱글 스레드 환경 최적화)<br />동적(Dynamic)로딩 | 비동기적(웹 환경 최적화)<br />정적(Static) 로딩      |
| 런타임 지원 | **Node.js 기본 지원**                                  | **브라우저 & 최신 Node.js 지원**                     |
| 동적 임포트 | ❌ 불가능 (무조건 정적)                                 | ✅ 가능 (`import()`)                                  |
| 파일 확장자 | `.js`                                                  | `.mjs` 또는 `package.json`에 `"type": "module"` 추가 |
| 성능 최적화 | 캐싱이 강함 (`require()`는 한 번 로드하면 계속 유지)   | 트리 셰이킹(Tree Shaking) 최적화 가능                |

서버에서는 "빠른 실행"이 중요하기 때문에, CommonJS가 선호되는 경우가 많다.

<br/>

<br/>

### 오늘의 회고

JavaScript는 객체지향, 명령형, 선언형 스타일 등 다양한 스타일을 지원하지만 그 중 **함수형 프로그래밍 패러다임**을 강력히 지원한다.

- 함수형 프로그래밍의 가장 큰 특징 중 하나는 일급 함수다.
  - 함수를 "값"처럼 다룰 수 있고, 이를 통해서 다양한 패턴을 구현할 수 있다.
- 또한, 기존 JavaScript에서는 모든 코드가 전역공간에 존재했기 때문에, 같은 이름의 변수가 충돌할 가능성이 존재했다.
  - 이를 해결하기 위해서 모듈 시스템이 필요하고, JavaScript에서는 CommonJS와 ESM을 지원한다.

<br/>

오늘은 몸이 안좋아서 오후부터 공부를 시작했다. 그래서 공부할 시간이 충분하지 않았다.

내일은 조금 더 집중해서 빠르게 정리를 끝내고, 실습 활동을 빠르게 경험할 수 있도록 노력해야겠다.

<br/>

### 참고 자료 및 링크
- [JavaScript(mdn)](https://developer.mozilla.org/ko/docs/Web/JavaScript)
- [IIFE](https://developer.mozilla.org/ko/docs/Glossary/IIFE)
- [CommonJS & ESM](https://toss.tech/article/commonjs-esm-exports-field)
